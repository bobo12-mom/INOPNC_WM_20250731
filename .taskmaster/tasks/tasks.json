{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Implement PWA Manifest and Basic Setup",
        "description": "Create PWA manifest.json with app metadata, icons, and configuration for installable web app experience",
        "details": "Create public/manifest.json with app name, short_name, description, icons (multiple sizes: 192x192, 512x512), start_url, display: 'standalone', orientation: 'portrait', theme_color matching brand colors, background_color for splash screen. Update app/layout.tsx to include manifest link and meta tags for mobile web app capable. Generate icon set using construction-themed logo. Configure next.config.js for PWA support.",
        "testStrategy": "Verify manifest loads correctly using Chrome DevTools Application tab. Test installability on mobile devices (Android Chrome, iOS Safari). Validate icon display across different devices. Use Lighthouse PWA audit to ensure manifest meets requirements. Test app installation flow and verify standalone mode behavior.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Service Worker with Caching Strategy",
        "description": "Create service worker for offline functionality with intelligent caching strategies for construction site usage",
        "details": "Implement service worker using Workbox or native APIs. Create cache-first strategy for static assets (JS, CSS, images). Network-first with cache fallback for API calls. Cache daily reports, material lists, and user data for offline access. Implement background sync for form submissions when offline. Handle cache versioning and cleanup. Special handling for large image files from construction photos. Size limits for mobile devices (max 500MB cache).",
        "testStrategy": "Test offline functionality by disabling network in DevTools. Verify cached pages load correctly offline. Test form submission queuing and sync when back online. Monitor cache size and cleanup. Test on low-end devices with limited storage. Verify service worker updates properly.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement Push Notifications System",
        "description": "Add push notification support for critical construction site updates and approvals",
        "details": "Implement Web Push API integration with service worker. Create notification permission flow with clear value proposition. Set up server-side push notification service using Supabase Edge Functions or external service (OneSignal/FCM). Define notification types: material request approvals, daily report reminders, safety alerts, equipment maintenance due. Create notification preferences UI in settings. Handle notification click actions to deep link into app. Implement notification badges and silent notifications.",
        "testStrategy": "Test permission flow across different browsers. Verify notifications arrive on multiple devices. Test notification actions and deep linking. Monitor delivery rates and engagement. Test notification preferences persistence. Verify silent notifications update app state.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Create Analytics Dashboard Infrastructure",
        "description": "Build comprehensive analytics dashboard backend with data aggregation and API endpoints",
        "details": "Design analytics database schema for metrics storage. Create Supabase functions for data aggregation: daily report completion rates, material usage trends, attendance patterns, equipment utilization, site productivity metrics. Implement time-series data storage for historical analysis. Create REST API endpoints for dashboard data. Set up real-time data streaming for live metrics. Implement data retention policies. Create role-based access for analytics (site managers see their sites, admins see all).",
        "testStrategy": "Test data aggregation accuracy with known datasets. Verify API performance with large data volumes. Test real-time updates with concurrent users. Validate role-based data filtering. Monitor query performance and optimize indexes. Test data retention and archival processes.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Build Analytics Dashboard UI Components",
        "description": "Create interactive analytics dashboard with charts, KPIs, and reporting features",
        "details": "Implement dashboard using Recharts or Chart.js for visualizations. Create KPI cards for key metrics: active workers, daily report completion, material usage, equipment status. Build time-series charts for trends analysis. Implement date range selectors and filters by site/project. Create comparative analysis views (site vs site, period vs period). Export functionality for reports (PDF/Excel). Mobile-responsive grid layout. Real-time metric updates using Supabase subscriptions.",
        "testStrategy": "Test chart rendering with various data ranges. Verify mobile responsiveness of charts. Test export functionality across formats. Validate real-time updates without performance degradation. Test filter combinations and edge cases. Verify accessibility of data visualizations.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Performance Monitoring System",
        "description": "Set up comprehensive application performance monitoring and alerting infrastructure",
        "details": "Integrate Sentry or similar APM for error tracking and performance monitoring. Implement custom performance metrics: page load times, API response times, database query performance. Set up real user monitoring (RUM) for actual user experience data. Create performance budgets and alerts. Implement server-side monitoring for Supabase functions. Track Core Web Vitals (LCP, FID, CLS). Set up automated performance regression testing. Create performance dashboard for operations team.",
        "testStrategy": "Verify error tracking captures all exceptions. Test performance metrics accuracy against manual measurements. Validate alert thresholds trigger appropriately. Test RUM data collection across devices. Verify no performance impact from monitoring itself. Test dashboard data accuracy and real-time updates.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Production Environment Setup and Security Hardening",
        "description": "Configure production infrastructure with security best practices and monitoring",
        "details": "Set up production Supabase project with proper RLS policies review. Configure production environment variables and secrets management. Implement API rate limiting and DDoS protection. Set up WAF rules for common attacks. Configure CORS policies for production domains. Implement request signing for sensitive operations. Set up automated security scanning (OWASP ZAP, Snyk). Configure backup automation with point-in-time recovery. Implement audit logging for compliance. Set up VPN access for admin operations.",
        "testStrategy": "Perform penetration testing on production setup. Test backup and recovery procedures. Verify rate limiting works without affecting legitimate users. Test RLS policies with different user roles. Validate audit logs capture required events. Test disaster recovery runbook. Verify security headers are properly set.",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Automated Deployment Pipeline",
        "description": "Create CI/CD pipeline for automated testing, building, and deployment to production",
        "details": "Set up GitHub Actions for CI/CD pipeline. Implement automated testing on PR: unit tests, integration tests, E2E tests with Playwright. Add code quality checks: ESLint, TypeScript, bundle size analysis. Create staging environment for pre-production testing. Implement blue-green deployment strategy for zero-downtime updates. Set up automated database migrations with rollback capability. Configure deployment notifications to Slack/Discord. Implement feature flags for gradual rollouts. Create deployment documentation and runbooks.",
        "testStrategy": "Test full deployment pipeline with dummy changes. Verify rollback procedures work correctly. Test database migration scenarios including failures. Validate zero-downtime deployment with active users. Test feature flag activation/deactivation. Monitor deployment metrics and success rates. Verify all team members can trigger deployments safely.",
        "priority": "high",
        "dependencies": [
          7
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Stabilize and Fix Test Suite for CI/CD Integration",
        "description": "Fix failing tests across the codebase, addressing React Testing Library act() wrapper issues, timeout problems, and asynchronous operation handling to ensure stable CI/CD pipeline execution",
        "details": "Comprehensive test suite stabilization focusing on 91 failing tests. Key issues to address: 1) React Testing Library act() warnings - wrap all state updates and effects in act() blocks, use waitFor() for async operations, implement proper cleanup in afterEach hooks. 2) Timeout issues - increase test timeouts for integration tests (jest.setTimeout), optimize slow tests by mocking external dependencies, implement proper async/await patterns. 3) Asynchronous handling - use findBy queries instead of getBy for async elements, properly await all promises before assertions, mock Supabase calls with consistent responses. 4) Test isolation - ensure tests don't share state, mock timers and dates for consistency, clear all mocks between tests. 5) Environment setup - configure test environment variables, setup MSW for API mocking, create test utilities for common operations. 6) CI/CD optimization - parallelize test runs, implement test result caching, add retry mechanism for flaky tests. Tools: Jest, React Testing Library, MSW for API mocking, jest-dom for better assertions. Create comprehensive test helpers in __tests__/utils/ for common patterns like authenticated user setup, form submissions, and async operations.",
        "testStrategy": "1) Run full test suite locally to baseline current failures (npm test). 2) Fix tests incrementally by category: unit tests first, then integration, finally E2E. 3) Verify each fix doesn't break other tests. 4) Test in CI environment using act workflow (GitHub Actions) to ensure environment parity. 5) Monitor test execution time and optimize slow tests. 6) Implement test coverage reporting and ensure minimum 80% coverage. 7) Run tests in different Node versions (18, 20) to ensure compatibility. 8) Stress test with parallel execution to identify race conditions. 9) Document common test patterns and gotchas for team reference. 10) Set up pre-commit hooks to run affected tests before push.",
        "status": "done",
        "dependencies": [
          8
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Setup Comprehensive Testing Infrastructure and Mock Utilities",
        "description": "Create robust testing infrastructure with proper Supabase mocking, test utilities, and fix existing test configuration issues to enable reliable test execution",
        "details": "1. Create testing utilities directory structure:\n   - `/lib/test-utils/supabase-mock.ts` - Comprehensive Supabase client mock\n   - `/lib/test-utils/auth-helpers.ts` - Authentication test utilities\n   - `/lib/test-utils/render-helpers.tsx` - React component test wrappers\n   - `/lib/test-utils/async-helpers.ts` - Async operation utilities\n\n2. Implement `createMockSupabaseClient()`:\n   ```typescript\n   export const createMockSupabaseClient = () => {\n     return {\n       auth: {\n         getSession: jest.fn().mockResolvedValue({ data: { session: mockSession }, error: null }),\n         signIn: jest.fn(),\n         signOut: jest.fn(),\n         onAuthStateChange: jest.fn(() => ({ data: { subscription: { unsubscribe: jest.fn() } } }))\n       },\n       from: jest.fn(() => ({\n         select: jest.fn().mockReturnThis(),\n         insert: jest.fn().mockReturnThis(),\n         update: jest.fn().mockReturnThis(),\n         delete: jest.fn().mockReturnThis(),\n         eq: jest.fn().mockReturnThis(),\n         single: jest.fn()\n       }))\n     };\n   };\n   ```\n\n3. Fix jest.config.js and setup files:\n   - Configure module aliases properly\n   - Set up global test environment variables\n   - Configure proper async timeout handling\n   - Add setup files for consistent mock initialization\n\n4. Create test data factories using @faker-js/faker:\n   - User factory with roles\n   - Organization/Site factories\n   - Document/Report factories\n\n5. Implement MSW (Mock Service Worker) for API mocking:\n   - Set up request handlers for all API endpoints\n   - Create scenario-based response generators\n   - Configure for both Node and browser environments",
        "testStrategy": "1. Unit test all mock utilities to ensure they behave like real Supabase client\n2. Create integration tests verifying mock utilities work with actual components\n3. Test that async helpers properly handle timeouts and loading states\n4. Verify test isolation - no test should affect another\n5. Benchmark test execution time to ensure <30s for full suite",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Implement Critical Authentication and Security Tests (Phase 1)",
        "description": "Achieve 100% test coverage for authentication flows, middleware, and protected route access control to ensure application security foundation",
        "details": "1. Test `/lib/supabase/server.ts` cookie handling:\n   ```typescript\n   describe('Supabase Server Client', () => {\n     it('handles cookie operations with try-catch blocks', async () => {\n       const mockCookieStore = createMockCookieStore();\n       // Test cookie get/set/remove operations\n       // Verify error handling doesn't break auth flow\n     });\n   });\n   ```\n\n2. Test middleware authentication (`/middleware.ts`):\n   - Test unauthenticated request redirects\n   - Test session refresh logic\n   - Test protected route patterns\n   - Test public route access\n\n3. Test server actions in `/app/auth/actions.ts`:\n   - Test login with valid/invalid credentials\n   - Test signup with validation\n   - Test password reset flow\n   - Verify all actions return {success, error} objects\n   - Ensure no redirect() calls in server actions\n\n4. Test auth hooks and utilities:\n   - useAuth() hook behavior\n   - Session persistence\n   - Token refresh handling\n   - Role-based access control\n\n5. Test protected route components:\n   - Verify redirect behavior for unauthenticated users\n   - Test role-based component rendering\n   - Test loading states during auth checks",
        "testStrategy": "1. Use createMockSupabaseClient() for all auth tests\n2. Test both success and failure paths for each auth operation\n3. Verify security headers and CORS configuration\n4. Test rate limiting and brute force protection\n5. Measure coverage using jest --coverage for auth modules\n6. Target: 100% statement, branch, and function coverage for auth code",
        "priority": "high",
        "dependencies": [
          10
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Test Core API Endpoints and Database Operations (Phase 2)",
        "description": "Implement comprehensive API endpoint testing for markup-documents, sites, and health check endpoints with proper request/response validation",
        "details": "1. Test `/api/markup-documents` endpoints:\n   ```typescript\n   describe('Markup Documents API', () => {\n     it('GET /api/markup-documents - lists with pagination', async () => {\n       const response = await GET('/api/markup-documents?page=1&limit=10');\n       expect(response.documents).toHaveLength(10);\n       expect(response.pagination).toBeDefined();\n     });\n     \n     it('POST /api/markup-documents - creates with validation', async () => {\n       const payload = createMarkupDocumentPayload();\n       const response = await POST('/api/markup-documents', payload);\n       expect(response.id).toBeDefined();\n       // Verify database persistence\n     });\n   });\n   ```\n\n2. Test request validation:\n   - Invalid payloads return 400 errors\n   - Missing required fields\n   - Type validation\n   - SQL injection prevention\n\n3. Test database transactions:\n   - Rollback on errors\n   - Concurrent request handling\n   - Connection pooling behavior\n\n4. Test error scenarios:\n   - Database connection failures\n   - Constraint violations\n   - Race conditions\n   - Network timeouts\n\n5. Test RLS (Row Level Security):\n   - Users can only access their data\n   - Site-based access control\n   - Admin override permissions\n\n6. Performance tests:\n   - Response time < 200ms for GET\n   - Batch operations efficiency\n   - Query optimization verification",
        "testStrategy": "1. Use MSW to intercept and verify API calls\n2. Test with real database using test transactions\n3. Verify response schemas match TypeScript types\n4. Test pagination edge cases (empty results, last page)\n5. Use jest-extended for better assertions\n6. Target: 90% coverage for all API route files",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Test Business Logic and Server Actions (Phase 3)",
        "description": "Achieve comprehensive test coverage for all server actions including daily reports, attendance management, and complex business calculations",
        "details": "1. Test daily report operations (`/app/actions/daily-reports.ts`):\n   ```typescript\n   describe('Daily Report Actions', () => {\n     it('creates report with weather and worker data', async () => {\n       const result = await createDailyReport({\n         siteId: 'test-site',\n         date: '2024-01-01',\n         weather: 'sunny',\n         workers: [{ id: 'w1', laborHours: 1.0 }]\n       });\n       expect(result.success).toBe(true);\n       expect(result.data.id).toBeDefined();\n     });\n   });\n   ```\n\n2. Test attendance/labor hours calculations:\n   - 1.0 공수 = 8 hours validation\n   - Overtime calculations\n   - Monthly aggregations\n   - Holiday handling\n\n3. Test notification system:\n   - Notification creation triggers\n   - Batch notification sending\n   - Read/unread status updates\n   - Push notification integration\n\n4. Test document operations:\n   - File upload with virus scanning\n   - Document permissions\n   - Soft delete functionality\n   - Storage quota enforcement\n\n5. Test complex workflows:\n   - Multi-step approval processes\n   - Concurrent edit handling\n   - Data consistency across related entities\n   - Audit trail generation\n\n6. Test data validation:\n   - Korean phone number formats\n   - Business registration numbers\n   - Date/time with timezone handling",
        "testStrategy": "1. Create test scenarios for each business rule\n2. Use database snapshots for complex state testing\n3. Verify all calculations with known test cases\n4. Test error handling and rollback mechanisms\n5. Mock external services (weather API, SMS, etc.)\n6. Target: 95% coverage for business logic files",
        "priority": "medium",
        "dependencies": [
          12
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Implement Component Testing and E2E Test Suite (Phases 4-5)",
        "description": "Create comprehensive component tests and end-to-end test scenarios to achieve 80% overall coverage target",
        "details": "1. Component Testing Setup:\n   ```typescript\n   // Markup Canvas Component Test\n   describe('MarkupCanvas', () => {\n     it('handles drawing operations', async () => {\n       const { canvas } = renderWithProviders(<MarkupCanvas />);\n       fireEvent.mouseDown(canvas, { clientX: 100, clientY: 100 });\n       fireEvent.mouseMove(canvas, { clientX: 200, clientY: 200 });\n       fireEvent.mouseUp(canvas);\n       expect(getDrawnObjects()).toHaveLength(1);\n     });\n   });\n   ```\n\n2. Test critical components:\n   - Markup editor with all tools\n   - Calendar with 공수 visualization\n   - Data tables with sorting/filtering\n   - Form components with validation\n   - File upload with progress\n\n3. E2E test scenarios using Playwright:\n   ```typescript\n   test('Complete work log submission flow', async ({ page }) => {\n     await page.goto('/auth/login');\n     await login(page, 'worker@inopnc.com', 'password123');\n     await page.goto('/dashboard/daily-reports/new');\n     await fillDailyReport(page);\n     await page.click('button[type=\"submit\"]');\n     await expect(page).toHaveURL('/dashboard/daily-reports');\n   });\n   ```\n\n4. Cross-browser testing:\n   - Chrome, Firefox, Safari compatibility\n   - Mobile responsive behavior\n   - Touch gesture support\n   - PWA functionality\n\n5. Performance testing:\n   - Initial load time < 3s\n   - Time to interactive < 5s\n   - Smooth scrolling at 60fps\n   - Memory leak detection\n\n6. Accessibility testing:\n   - Screen reader compatibility\n   - Keyboard navigation\n   - Color contrast compliance\n   - ARIA labels verification",
        "testStrategy": "1. Use React Testing Library for component tests\n2. Implement visual regression testing with Percy\n3. Create Playwright test suite for critical paths\n4. Run tests in CI/CD pipeline\n5. Generate coverage reports with detailed metrics\n6. Set up monitoring for test flakiness\n7. Target: 80% total coverage with no flaky tests",
        "priority": "medium",
        "dependencies": [
          13
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Enhanced Testing Utilities and Mock Framework",
        "description": "Create a robust testing infrastructure with comprehensive mock utilities that support all recent system changes including labor hours system, unified documents UI, PWA features, and Analytics API",
        "details": "Create /lib/test-utils/ directory structure and implement comprehensive mocking framework:\n\n1. Core Mock Framework:\n- createMockSupabaseClient() with full auth and database mocking\n- TypeScript types matching actual Supabase interfaces\n\n2. Labor Hours (공수) System Mocks:\n```typescript\n// lib/test-utils/factories/attendance.factory.ts\nexport const createMockAttendanceWithLaborHours = (overrides?: Partial<AttendanceRecord>) => ({\n  id: faker.string.uuid(),\n  work_date: faker.date.recent().toISOString(),\n  labor_hours: faker.helpers.arrayElement([0.25, 0.5, 0.75, 1.0, 1.25, 1.5]),\n  hours_worked: null,\n  site_name: faker.company.name(),\n  status: 'present',\n  ...overrides\n})\n\nexport const createMockPayslip = () => ({\n  month: '2025-08',\n  total_labor_hours: 22.5,\n  total_hours_worked: 180,\n  basic_salary: 3000000,\n  overtime_pay: 500000,\n  total_pay: 3500000\n})\n```\n\n3. Unified Documents System Mocks with card UI fields\n4. PWA Testing Infrastructure with service worker and push notification mocks\n5. Analytics API Mocks for metrics and web vitals",
        "testStrategy": "Unit test all mock utilities to ensure they reflect actual data structures. Test labor hours calculations (1.0 공수 = 8 hours conversion). Verify PDF generation mocks work correctly. Test PWA mock behavior in different states (online/offline, installed/not installed). Validate Analytics mock responses match actual API structure.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Jest Configuration for Modern Features",
        "description": "Update Jest configuration to support PWA testing, Analytics, and modern React features with proper module resolution and environment setup",
        "details": "Update jest.config.js with:\n\n1. Setup Files:\n```javascript\nsetupFilesAfterEnv: [\n  '<rootDir>/jest.setup.js',\n  '<rootDir>/lib/test-utils/pwa-setup.ts'\n]\n```\n\n2. Module Name Mapping:\n```javascript\nmoduleNameMapper: {\n  '^@/lib/test-utils/(.*)$': '<rootDir>/lib/test-utils/$1'\n}\n```\n\n3. Test Environment Options:\n```javascript\ntestEnvironmentOptions: {\n  customExportConditions: [''],\n  url: 'https://localhost:3000'\n}\n```\n\n4. TypeScript Configuration:\n```javascript\nglobals: {\n  'ts-jest': {\n    tsconfig: {\n      jsx: 'react-jsx'\n    }\n  }\n}\n```\n\n5. Create pwa-setup.ts for service worker and navigator mocking",
        "testStrategy": "Verify Jest can properly import and use test utilities. Test that PWA globals are available in test environment. Ensure TypeScript compilation works correctly with JSX. Validate module resolution for test utilities. Test that mock service worker setup doesn't interfere with other tests.",
        "priority": "high",
        "dependencies": [
          15
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Component Testing for New Features",
        "description": "Create comprehensive tests for components affected by recent changes including attendance tab with labor hours, unified documents tab with card layout, and PWA-enabled components",
        "details": "Implement component tests for:\n\n1. Attendance Tab with Labor Hours:\n```typescript\n// __tests__/components/dashboard/tabs/attendance-tab.test.tsx\n- Test labor hours display in calendar (1.0 공수 format)\n- Test color coding: green (1.0+), yellow (0.5-0.9), orange (0.1-0.4)\n- Test PDF payslip generation with correct calculations\n- Test labor hours to work hours conversion (1.0 공수 = 8 hours)\n```\n\n2. Unified Documents Tab:\n```typescript\n// __tests__/components/dashboard/tabs/documents-tab.test.tsx\n- Test card-based UI rendering\n- Test file type badges with correct colors\n- Test personal/shared document filtering\n- Test document actions (download, delete, share)\n```\n\n3. PWA Components:\n- Test install prompt component\n- Test offline indicator\n- Test push notification permission request",
        "testStrategy": "Use React Testing Library for component testing. Mock Supabase calls with test utilities. Test user interactions and state changes. Verify accessibility with testing-library queries. Test responsive behavior for mobile/desktop views. Validate PDF generation triggers and downloads correctly.",
        "priority": "high",
        "dependencies": [
          15,
          16
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "API Testing for New Endpoints",
        "description": "Implement tests for Analytics API endpoints and updated attendance endpoints that handle labor hours and web vitals data",
        "details": "Create API route tests:\n\n1. Analytics Metrics API:\n```typescript\n// __tests__/api/analytics/metrics.test.ts\n- Test GET /api/analytics/metrics returns labor_hours aggregations\n- Test date range filtering\n- Test response includes daily_reports_count, active_users, documents_uploaded\n- Test error handling for invalid date ranges\n```\n\n2. Web Vitals API:\n```typescript\n// __tests__/api/analytics/web-vitals.test.ts\n- Test POST /api/analytics/web-vitals stores LCP, FID, CLS data\n- Test data validation for performance metrics\n- Test batch submission of multiple vitals\n```\n\n3. Updated Attendance API:\n```typescript\n// __tests__/api/attendance/*.test.ts\n- Test labor_hours field in responses\n- Test payslip generation endpoint\n- Test labor hours calculations and aggregations\n```\n\n4. Implement request/response mocking with MSW or similar",
        "testStrategy": "Test API routes in isolation using Next.js API testing patterns. Mock Supabase client to avoid database calls. Validate request/response schemas. Test error scenarios and edge cases. Verify proper HTTP status codes. Test authentication and authorization for protected endpoints.",
        "priority": "medium",
        "dependencies": [
          15,
          16
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "E2E Testing with PWA Features",
        "description": "Create E2E tests using Playwright that validate PWA functionality, labor hours workflow, and new user flows across the application",
        "details": "Implement Playwright E2E tests:\n\n1. PWA Installation and Offline:\n```typescript\n// e2e/pwa-features.spec.ts\n- Test service worker registration on first visit\n- Test app installation prompt appearance and interaction\n- Test offline page display when network is disconnected\n- Test background sync when coming back online\n```\n\n2. Labor Hours Workflow:\n```typescript\n// e2e/labor-hours-workflow.spec.ts\n- Navigate to attendance tab\n- Enter labor hours (test 0.25, 0.5, 1.0 공수 options)\n- Verify calendar display updates with correct colors\n- Generate PDF payslip\n- Verify calculations (22.5 공수 * 8 = 180 hours)\n```\n\n3. Unified Documents Flow:\n```typescript\n// e2e/documents-management.spec.ts\n- Upload documents of different types\n- Verify card layout display\n- Test switching between personal/shared tabs\n- Test document actions across different file types\n```\n\n4. Analytics Dashboard:\n- Test real-time metrics update\n- Verify web vitals collection",
        "testStrategy": "Use Playwright's network interception to test offline scenarios. Test on multiple browsers (Chrome, Firefox, Safari). Use visual regression testing for UI consistency. Test mobile viewport for responsive features. Implement page object model for maintainable tests. Test critical user journeys end-to-end.",
        "priority": "medium",
        "dependencies": [
          15,
          16,
          17,
          18
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Admin Document Management System for PTW and Blueprint Files",
        "description": "Implement a complete document management system in the admin dashboard for uploading, managing, and selecting PTW and blueprint documents per site. Replace hardcoded file previews with dynamic document selection using Supabase Storage.",
        "details": "Build a comprehensive document management system integrated with Supabase Storage:\n\n1. Database Schema Updates:\n```sql\n-- Create site_documents table\nCREATE TABLE site_documents (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  site_id UUID REFERENCES sites(id) ON DELETE CASCADE,\n  document_type VARCHAR(50) CHECK (document_type IN ('ptw', 'blueprint', 'other')),\n  file_name VARCHAR(255) NOT NULL,\n  file_url TEXT NOT NULL,\n  file_size INTEGER,\n  mime_type VARCHAR(100),\n  uploaded_by UUID REFERENCES profiles(id),\n  is_active BOOLEAN DEFAULT true,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\n-- Add RLS policies\nCREATE POLICY \"Admins can manage site documents\" ON site_documents\n  FOR ALL USING (EXISTS (\n    SELECT 1 FROM profiles WHERE profiles.id = auth.uid() \n    AND profiles.role IN ('admin', 'system_admin')\n  ));\n\nCREATE POLICY \"All authenticated users can view active documents\" ON site_documents\n  FOR SELECT USING (is_active = true AND auth.uid() IS NOT NULL);\n```\n\n2. Supabase Storage Setup:\n```typescript\n// lib/supabase/storage.ts\nexport const STORAGE_BUCKETS = {\n  SITE_DOCUMENTS: 'site-documents'\n} as const;\n\nexport async function uploadSiteDocument(\n  file: File,\n  siteId: string,\n  documentType: 'ptw' | 'blueprint' | 'other'\n) {\n  const fileExt = file.name.split('.').pop();\n  const fileName = `${siteId}/${documentType}/${Date.now()}.${fileExt}`;\n  \n  const { data, error } = await supabase.storage\n    .from(STORAGE_BUCKETS.SITE_DOCUMENTS)\n    .upload(fileName, file);\n    \n  if (error) throw error;\n  \n  const { data: { publicUrl } } = supabase.storage\n    .from(STORAGE_BUCKETS.SITE_DOCUMENTS)\n    .getPublicUrl(fileName);\n    \n  return { fileName, publicUrl };\n}\n```\n\n3. Admin Document Management UI:\n```typescript\n// components/admin/SiteDocumentManagement.tsx\nexport function SiteDocumentManagement({ siteId }: { siteId: string }) {\n  const [documents, setDocuments] = useState<SiteDocument[]>([]);\n  const [uploading, setUploading] = useState(false);\n  \n  const handleUpload = async (file: File, type: DocumentType) => {\n    setUploading(true);\n    try {\n      const { fileName, publicUrl } = await uploadSiteDocument(file, siteId, type);\n      \n      const { data, error } = await supabase\n        .from('site_documents')\n        .insert({\n          site_id: siteId,\n          document_type: type,\n          file_name: file.name,\n          file_url: publicUrl,\n          file_size: file.size,\n          mime_type: file.type,\n          uploaded_by: user.id\n        })\n        .select()\n        .single();\n        \n      if (error) throw error;\n      setDocuments([...documents, data]);\n    } catch (error) {\n      toast.error('Upload failed');\n    } finally {\n      setUploading(false);\n    }\n  };\n  \n  return (\n    <div className=\"space-y-6\">\n      <DocumentUploadZone onUpload={handleUpload} disabled={uploading} />\n      <DocumentList \n        documents={documents} \n        onDelete={handleDelete}\n        onSetActive={handleSetActive}\n      />\n    </div>\n  );\n}\n```\n\n4. Document Upload Component:\n```typescript\n// components/admin/DocumentUploadZone.tsx\nexport function DocumentUploadZone({ onUpload, disabled }: Props) {\n  const [dragActive, setDragActive] = useState(false);\n  const [documentType, setDocumentType] = useState<DocumentType>('ptw');\n  \n  const handleDrop = (e: React.DragEvent) => {\n    e.preventDefault();\n    const file = e.dataTransfer.files[0];\n    if (file) onUpload(file, documentType);\n  };\n  \n  return (\n    <div className=\"space-y-4\">\n      <Select value={documentType} onValueChange={setDocumentType}>\n        <SelectTrigger>\n          <SelectValue />\n        </SelectTrigger>\n        <SelectContent>\n          <SelectItem value=\"ptw\">PTW (작업허가서)</SelectItem>\n          <SelectItem value=\"blueprint\">공사도면</SelectItem>\n          <SelectItem value=\"other\">기타 문서</SelectItem>\n        </SelectContent>\n      </Select>\n      \n      <div\n        className={cn(\n          \"border-2 border-dashed rounded-lg p-8 text-center\",\n          dragActive && \"border-primary bg-primary/5\",\n          disabled && \"opacity-50 cursor-not-allowed\"\n        )}\n        onDragOver={(e) => { e.preventDefault(); setDragActive(true); }}\n        onDragLeave={() => setDragActive(false)}\n        onDrop={handleDrop}\n      >\n        <Upload className=\"mx-auto h-12 w-12 text-muted-foreground\" />\n        <p className=\"mt-2\">드래그 앤 드롭 또는 클릭하여 파일 선택</p>\n        <p className=\"text-sm text-muted-foreground\">PDF, JPG, PNG (최대 10MB)</p>\n      </div>\n    </div>\n  );\n}\n```\n\n5. Update Site Info Component to Use Dynamic Documents:\n```typescript\n// components/site-info/TodaySiteInfo.tsx\nconst { data: activeDocuments } = await supabase\n  .from('site_documents')\n  .select('*')\n  .eq('site_id', siteId)\n  .eq('is_active', true);\n\nconst ptwDocument = activeDocuments?.find(doc => doc.document_type === 'ptw');\nconst blueprintDocument = activeDocuments?.find(doc => doc.document_type === 'blueprint');\n\n// Use document URLs in modals\n<BlueprintModal \n  isOpen={showBlueprint}\n  onClose={() => setShowBlueprint(false)}\n  blueprintUrl={blueprintDocument?.file_url || '/placeholder-blueprint.jpg'}\n/>\n```\n\n6. Admin Dashboard Integration:\n```typescript\n// app/dashboard/admin/sites/[id]/documents/page.tsx\nexport default async function SiteDocumentsPage({ params }: { params: { id: string } }) {\n  const site = await getSiteById(params.id);\n  \n  return (\n    <div className=\"container mx-auto py-6\">\n      <h1 className=\"text-2xl font-bold mb-6\">\n        {site.name} - 문서 관리\n      </h1>\n      <SiteDocumentManagement siteId={params.id} />\n    </div>\n  );\n}\n```\n\n7. File Validation and Security:\n```typescript\n// lib/validators/file.ts\nexport const validateDocument = (file: File) => {\n  const MAX_SIZE = 10 * 1024 * 1024; // 10MB\n  const ALLOWED_TYPES = ['application/pdf', 'image/jpeg', 'image/png'];\n  \n  if (file.size > MAX_SIZE) {\n    throw new Error('파일 크기는 10MB를 초과할 수 없습니다');\n  }\n  \n  if (!ALLOWED_TYPES.includes(file.type)) {\n    throw new Error('PDF, JPG, PNG 파일만 업로드 가능합니다');\n  }\n  \n  return true;\n};\n```",
        "testStrategy": "Comprehensive testing approach for document management system:\n\n1. Database Tests:\n- Verify site_documents table creation and constraints\n- Test RLS policies for admin-only write access\n- Verify authenticated users can read active documents\n- Test cascade deletion when site is deleted\n\n2. Storage Integration Tests:\n- Test file upload to Supabase Storage with correct bucket structure\n- Verify public URL generation works correctly\n- Test file size and type validation\n- Verify error handling for upload failures\n\n3. Component Tests:\n- Test DocumentUploadZone drag-and-drop functionality\n- Verify file type selection updates correctly\n- Test upload progress indication\n- Verify document list displays uploaded files\n- Test delete and set-active functionality\n\n4. Integration Tests:\n- Upload a PTW document and verify it appears in site info\n- Upload a blueprint and test preview modal displays correct file\n- Test replacing an active document with a new version\n- Verify non-admin users cannot access upload interface\n\n5. E2E Tests:\n- Complete workflow: Admin uploads PTW → Worker views in site info\n- Test multiple file uploads and active document selection\n- Verify proper error messages for invalid files\n- Test document persistence across sessions",
        "status": "done",
        "dependencies": [
          3,
          9,
          13
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Critical Stability Issues Resolution - Zero Build Errors",
        "description": "Fix all build-blocking errors including React Hooks conditional calls, TypeScript parsing errors, and component definition issues to achieve zero build errors and successful production build under 30 seconds",
        "details": "Comprehensive build stabilization focusing on critical errors:\n\n1. React Hooks Violations:\n```typescript\n// Identify and fix conditional hook calls\n// Before:\nif (condition) {\n  useEffect(() => {}, []); // ERROR: Conditional hook\n}\n\n// After:\nuseEffect(() => {\n  if (condition) {\n    // Logic here\n  }\n}, [condition]);\n```\n\n2. TypeScript Parsing Errors:\n- Fix missing type imports and circular dependencies\n- Resolve 'any' type usage in strict mode\n- Fix generic type parameter issues\n- Address module resolution errors\n```typescript\n// Add proper type exports/imports\nexport type { MarkupDocument } from './types';\nimport type { Database } from '@/types/supabase';\n```\n\n3. Component Definition Issues:\n- Fix missing or duplicate component exports\n- Resolve forward ref issues\n- Fix HOC type definitions\n```typescript\n// Proper component typing\nconst MyComponent = forwardRef<HTMLDivElement, Props>(\n  ({ children, ...props }, ref) => {\n    return <div ref={ref} {...props}>{children}</div>;\n  }\n);\nMyComponent.displayName = 'MyComponent';\n```\n\n4. Build Configuration:\n- Update next.config.js for proper module resolution\n- Fix webpack configuration issues\n- Optimize build performance settings\n```javascript\n// next.config.js\nmodule.exports = {\n  typescript: {\n    ignoreBuildErrors: false,\n  },\n  eslint: {\n    ignoreDuringBuilds: false,\n  },\n  swcMinify: true,\n  compiler: {\n    removeConsole: process.env.NODE_ENV === 'production',\n  },\n};\n```\n\n5. Dependency Issues:\n- Update mismatched dependency versions\n- Fix peer dependency warnings\n- Resolve module not found errors\n\n6. ESLint Configuration:\n- Fix ESLint rules causing build failures\n- Add proper ignores for generated files\n- Configure rules for React 18+ patterns",
        "testStrategy": "1. Baseline Build Analysis:\n- Run `npm run build` and capture all error types\n- Categorize errors by type (Hooks, TypeScript, Components)\n- Document error counts for progress tracking\n\n2. Incremental Fix Verification:\n- Fix one category at a time\n- Run `npm run build` after each fix category\n- Ensure no regression in other areas\n\n3. TypeScript Validation:\n- Run `npx tsc --noEmit` for pure type checking\n- Verify no TypeScript errors remain\n- Check strict mode compliance\n\n4. Linting Validation:\n- Run `npm run lint` with --max-warnings 0\n- Fix all ESLint errors and warnings\n- Verify no linting issues block build\n\n5. Production Build Testing:\n- Time production builds: `time npm run build`\n- Target: Under 30 seconds for full build\n- Verify build output size is reasonable\n\n6. Build Output Verification:\n- Check .next/build-manifest.json for all pages\n- Verify static pages are properly generated\n- Ensure API routes are included\n\n7. Development Mode Testing:\n- Run `npm run dev` and verify no runtime errors\n- Test hot module replacement works\n- Verify no console errors in browser\n\n8. CI/CD Integration:\n- Run build in GitHub Actions\n- Ensure build passes in clean environment\n- Verify no environment-specific issues",
        "status": "done",
        "dependencies": [
          9,
          16
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Fix React Hooks Violations and Rules of Hooks Errors",
            "description": "Identify and fix all conditional hook calls, hooks called inside loops, and hooks called after early returns to comply with React's Rules of Hooks",
            "dependencies": [],
            "details": "Scan entire codebase for React Hooks violations using ESLint react-hooks/rules-of-hooks rule. Common patterns to fix: 1) Conditional hooks - move conditions inside hook callbacks, 2) Hooks in loops - restructure to use single hook with array dependencies, 3) Hooks after returns - ensure all hooks are called at top level before any conditional returns. Focus on components in /components and /app directories. Use automated tools like eslint --fix where possible, but manually verify each fix to ensure logic remains correct.",
            "status": "done",
            "testStrategy": "Run npm run lint to identify all hooks violations. After fixes, run npm run build to verify no hooks errors remain. Create unit tests for refactored components to ensure behavior unchanged. Use React Testing Library to test hook-dependent functionality."
          },
          {
            "id": 2,
            "title": "Resolve TypeScript Type Errors and Missing Type Definitions",
            "description": "Fix all TypeScript parsing errors including missing type imports, circular dependencies, implicit 'any' types, and generic type parameter issues",
            "dependencies": [],
            "details": "Address TypeScript errors systematically: 1) Fix missing type imports by adding proper import type statements, 2) Resolve circular dependencies by extracting shared types to separate files, 3) Replace implicit 'any' with proper types or explicit type annotations, 4) Fix generic type parameters in component props and function signatures, 5) Ensure all .d.ts files are properly referenced in tsconfig.json, 6) Update module resolution for @/ aliases, 7) Fix type exports to use 'export type' for type-only exports. Priority files: /types/index.ts, /types/supabase.ts, component prop interfaces.",
            "status": "done",
            "testStrategy": "Run tsc --noEmit to check TypeScript compilation without emitting files. Fix errors iteratively by category. Verify no type errors with npm run type-check. Test that IDE type inference works correctly after fixes."
          },
          {
            "id": 3,
            "title": "Fix Component Definition and Export Issues",
            "description": "Resolve all component definition problems including missing exports, duplicate exports, forward ref issues, and HOC type definitions",
            "dependencies": [
              "21.1",
              "21.2"
            ],
            "details": "Systematic component fixes: 1) Scan for missing default/named exports and add proper export statements, 2) Remove duplicate component exports causing conflicts, 3) Fix forwardRef components with proper type annotations and displayName, 4) Update HOC definitions with correct TypeScript generics, 5) Ensure all lazy-loaded components have proper Suspense boundaries, 6) Fix component file naming to match export names, 7) Add displayName to all components for better debugging. Focus on high-usage components first: page layouts, form components, dashboard tabs.",
            "status": "done",
            "testStrategy": "Create a component inventory script to verify all components export correctly. Test each fixed component renders without errors. Use React DevTools to verify displayNames appear correctly. Run build to ensure no component errors."
          },
          {
            "id": 4,
            "title": "Update Build Configuration and Dependencies",
            "description": "Fix build configuration issues in next.config.js, resolve dependency conflicts, and optimize build performance settings",
            "dependencies": [
              "21.3"
            ],
            "details": "Build configuration updates: 1) Update next.config.js with proper webpack configuration for module resolution, 2) Configure SWC minifier settings for optimal performance, 3) Fix peer dependency warnings by updating package versions, 4) Resolve conflicting dependency versions using npm dedupe, 5) Update ESLint config to prevent build-blocking rules, 6) Configure proper ignores for generated files (.next, node_modules), 7) Set up proper environment variable validation, 8) Enable strict mode for better error catching, 9) Configure proper publicRuntimeConfig and serverRuntimeConfig.",
            "status": "done",
            "testStrategy": "Run npm run build after each configuration change. Measure build time to ensure under 30 seconds target. Test production build with npm run start. Verify no console errors in production mode."
          },
          {
            "id": 5,
            "title": "Implement Build Verification and CI Protection",
            "description": "Create comprehensive build verification tests and CI pipeline to prevent future build-breaking changes",
            "dependencies": [
              "21.4"
            ],
            "details": "Build protection implementation: 1) Create pre-commit hooks using husky to run build checks, 2) Set up GitHub Actions workflow for build verification on every PR, 3) Implement build time monitoring to alert if exceeds 30 seconds, 4) Create automated tests that verify critical paths compile correctly, 5) Set up error reporting to track any build failures in CI, 6) Configure branch protection rules requiring successful builds, 7) Create build performance dashboard to track metrics over time, 8) Document common build errors and fixes in troubleshooting guide.",
            "status": "done",
            "testStrategy": "Test pre-commit hooks work by intentionally introducing build errors. Verify GitHub Actions catches build failures in PRs. Run load tests on build pipeline to ensure scalability. Monitor build times across different environments."
          }
        ]
      },
      {
        "id": 22,
        "title": "Phase 2: Data Completion - Generate Realistic Construction Site Data and Complete Business Logic",
        "description": "Implement comprehensive data generation for construction sites including worker profiles, daily reports, attendance records with labor hours, and complete business logic for payroll calculation and material management workflows",
        "details": "Implement realistic data generation and complete business logic systems:\n\n1. Data Generation Infrastructure:\n```typescript\n// lib/data-generation/generators.ts\nexport class ConstructionDataGenerator {\n  // Generate realistic Korean names for workers\n  generateWorkerProfile(): WorkerProfile {\n    return {\n      name: this.generateKoreanName(),\n      phone: this.generateKoreanPhone(),\n      role: this.selectRole(),\n      site_id: this.selectSite(),\n      skills: this.generateSkills(),\n      certifications: this.generateCertifications()\n    };\n  }\n\n  // Generate daily reports with realistic construction data\n  generateDailyReport(date: Date, siteId: string): DailyReport {\n    return {\n      date,\n      site_id: siteId,\n      weather: this.generateWeather(),\n      work_description: this.generateWorkDescription(),\n      materials_used: this.generateMaterialUsage(),\n      equipment_used: this.generateEquipmentUsage(),\n      safety_incidents: this.generateSafetyData(),\n      progress_percentage: this.calculateProgress()\n    };\n  }\n}\n```\n\n2. Payroll Calculation System:\n```typescript\n// lib/payroll/calculator.ts\nexport class PayrollCalculator {\n  calculateMonthlyPayroll(workerId: string, month: Date): PayrollResult {\n    const attendanceRecords = await this.getAttendanceRecords(workerId, month);\n    const totalLaborHours = attendanceRecords.reduce((sum, record) => sum + record.labor_hours, 0);\n    \n    const baseRate = await this.getWorkerBaseRate(workerId);\n    const overtimeHours = this.calculateOvertime(totalLaborHours);\n    const regularPay = (totalLaborHours - overtimeHours) * 8 * baseRate;\n    const overtimePay = overtimeHours * 8 * baseRate * 1.5;\n    \n    const deductions = this.calculateDeductions(regularPay + overtimePay);\n    const netPay = regularPay + overtimePay - deductions.total;\n    \n    return {\n      totalLaborHours,\n      regularPay,\n      overtimePay,\n      deductions,\n      netPay,\n      paymentDate: this.getPaymentDate(month)\n    };\n  }\n}\n```\n\n3. Material Management Workflow:\n```typescript\n// lib/materials/workflow.ts\nexport class MaterialManagementWorkflow {\n  async createMaterialRequest(request: MaterialRequestInput): Promise<MaterialRequest> {\n    // Validate inventory availability\n    const availability = await this.checkInventory(request.materials);\n    \n    // Create request with approval workflow\n    const materialRequest = await this.db.material_requests.create({\n      ...request,\n      status: 'pending_approval',\n      approval_levels: this.determineApprovalLevels(request.total_amount)\n    });\n    \n    // Notify approvers\n    await this.notifyApprovers(materialRequest);\n    \n    return materialRequest;\n  }\n  \n  async processMaterialApproval(requestId: string, approverId: string, decision: 'approve' | 'reject') {\n    const request = await this.getMaterialRequest(requestId);\n    \n    if (decision === 'approve') {\n      const allApproved = await this.checkAllApprovals(request);\n      if (allApproved) {\n        await this.fulfillMaterialRequest(request);\n        await this.updateInventory(request.materials);\n      }\n    }\n    \n    await this.notifyRequestor(request, decision);\n  }\n}\n```\n\n4. Seed Data Scripts:\n```typescript\n// scripts/seed-construction-data.ts\nasync function seedConstructionData() {\n  const generator = new ConstructionDataGenerator();\n  \n  // Generate 5 construction sites\n  const sites = await Promise.all(\n    Array(5).fill(null).map(() => generator.generateSite())\n  );\n  \n  // Generate 50 workers distributed across sites\n  const workers = await Promise.all(\n    Array(50).fill(null).map(() => generator.generateWorkerProfile())\n  );\n  \n  // Generate 6 months of historical data\n  for (const site of sites) {\n    await generateHistoricalData(site.id, 180);\n  }\n  \n  // Generate material inventory\n  await seedMaterialInventory();\n  \n  // Generate sample material requests with approval workflows\n  await generateMaterialRequests();\n}\n```\n\n5. Business Logic Integration:\n```typescript\n// app/api/payroll/generate/route.ts\nexport async function POST(request: Request) {\n  const { workerId, month } = await request.json();\n  const calculator = new PayrollCalculator();\n  \n  const payroll = await calculator.calculateMonthlyPayroll(workerId, month);\n  const pdf = await generatePayrollPDF(payroll);\n  \n  return new Response(pdf, {\n    headers: {\n      'Content-Type': 'application/pdf',\n      'Content-Disposition': `attachment; filename=\"payroll-${workerId}-${month}.pdf\"`\n    }\n  });\n}\n```",
        "testStrategy": "Comprehensive testing for data generation and business logic:\n\n1. Data Generation Tests:\n- Verify generated worker profiles have valid Korean names and phone numbers\n- Test daily report generation produces realistic construction data\n- Validate attendance records include proper labor hours (0.25, 0.5, 1.0 공수)\n- Ensure generated data maintains referential integrity\n\n2. Payroll Calculation Tests:\n- Test accurate labor hours to payment calculation\n- Verify overtime calculation (>22 days/month)\n- Test tax and insurance deduction calculations\n- Validate payroll PDF generation with correct formatting\n- Test edge cases: partial months, no attendance, maximum overtime\n\n3. Material Management Tests:\n- Test material request creation with inventory validation\n- Verify approval workflow routing based on amount thresholds\n- Test notification system for approvers and requestors\n- Validate inventory updates after approval\n- Test rejection flow and re-submission\n\n4. Integration Tests:\n- End-to-end test: Worker attendance → Payroll calculation → PDF generation\n- Material request → Multi-level approval → Inventory update\n- Test data consistency across related tables\n- Verify business rules enforcement\n\n5. Performance Tests:\n- Measure payroll calculation time for 100+ workers\n- Test material workflow with concurrent requests\n- Validate data generation doesn't exceed memory limits",
        "status": "done",
        "dependencies": [
          9,
          13,
          20,
          21
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Create ConstructionDataGenerator class for Korean worker profiles",
            "description": "Implement generator class for realistic Korean names, phone numbers, roles, and worker profiles",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 22
          },
          {
            "id": 2,
            "title": "Implement PayrollCalculator system with Korean labor hour calculations",
            "description": "Create payroll calculation system that handles 공수 (labor hours), overtime, deductions, and generates payroll results",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 22
          },
          {
            "id": 3,
            "title": "Build Material Management Workflow with approval routing",
            "description": "Implement material request creation, multi-level approval workflow, inventory validation, and notification system",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 22
          },
          {
            "id": 4,
            "title": "Create comprehensive seed data scripts",
            "description": "Generate 5 construction sites, 50 workers, 6 months historical data, material inventory, and sample requests",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 22
          },
          {
            "id": 5,
            "title": "Integrate business logic with API routes and test",
            "description": "Create API endpoints for payroll generation, material requests, and implement comprehensive tests",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 22
          }
        ]
      },
      {
        "id": 23,
        "title": "Phase 3: Performance Optimization",
        "description": "Improve Core Web Vitals and optimize database queries",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          "22"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Phase 4: User Experience Completion",
        "description": "Complete mobile UX optimization, PWA features, accessibility compliance, and Korean localization",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          "23"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "Phase 5: Production Deployment and Operations",
        "description": "Configure production environment, setup monitoring, implement backup and security measures for final deployment",
        "details": "",
        "testStrategy": "",
        "status": "in-progress",
        "dependencies": [
          "24"
        ],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-02T09:20:48.397Z",
      "updated": "2025-08-15T01:20:26.307Z",
      "description": "Tasks for master context"
    }
  }
}